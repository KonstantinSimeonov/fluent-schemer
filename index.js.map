{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap bc2ff7580f4fdc07836a","webpack:///./lib/schemas/base-schema.ts","webpack:///./lib/errors.ts","webpack:///./lib/is.ts","webpack:///./lib/schemas/array-schema.ts","webpack:///./lib/schemas/bool-schema.ts","webpack:///./lib/schemas/date-schema.ts","webpack:///./lib/schemas/enumeration-schema.ts","webpack:///./lib/schemas/number-schema.ts","webpack:///./lib/schemas/object-schema.ts","webpack:///./lib/schemas/string-schema.ts","webpack:///./lib/schemas/union-schema.ts","webpack:///./lib/index.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,0GAA0G,cAAc;AACxH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,OAAO;AACtB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,UAAU,WAAW,aAAa;AAChI;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,OAAO;AACtB,eAAe,IAAI;AACnB;AACA;AACA;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;;;;;;;AC9FA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;AChBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA,2EAA2E,SAAS;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,sEAAsE,2BAA2B;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG,MAAM;AACvG;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,mGAAmG,UAAU,wBAAwB,sBAAsB,kBAAkB,aAAa;AAC1L;AACA,oBAAoB;AACpB;AACA;AACA,mGAAmG,UAAU,uBAAuB,sBAAsB,kBAAkB,aAAa;AACzL;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA,2CAA2C,SAAS;AACpD,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnFA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACdA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,KAAK;AAC7D;AACA;AACA,mFAAmF,KAAK,YAAY,MAAM,OAAO,IAAI;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,KAAK,kBAAkB,MAAM,GAAG,IAAI,WAAW,MAAM;AACrI;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,oBAAoB;AAC5H;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA,gGAAgG,eAAe,WAAW,MAAM;AAChI;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,oBAAoB;AAC3H;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA,+FAA+F,cAAc,WAAW,MAAM;AAC9H;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvJA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,0BAA0B,WAAW,MAAM;AACzI;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3BA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH,SAAS,WAAW,MAAM;AACjJ;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,SAAS,WAAW,MAAM;AAC9I;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G,MAAM;AACpH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvEA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;;;;;;;AC5CA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,sBAAsB,WAAW,aAAa;AAC9J;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,sBAAsB,WAAW,aAAa;AAC7J;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,MAAM;AAC7F;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;ACvDA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fluent-schemer\"] = factory();\n\telse\n\t\troot[\"fluent-schemer\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap bc2ff7580f4fdc07836a","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst errors_1 = require(\"../errors\");\nexports.name = 'base';\nclass BaseSchema {\n    constructor() {\n        this.validationFunctions = [];\n    }\n    /**\n     * Adds a validation callback to the validations to be performed on a value passed to .validate()\n     * @param {function} validationFn\n     */\n    pushValidationFn(validationFn) {\n        this.validationFunctions.push(validationFn);\n    }\n    /**\n     * Values validated with this schema must match the schema type. Other types are not allowed by default.\n     * @returns {BaseSchema} - The current instance of the BaseSchema.\n     */\n    required() {\n        this._required = true;\n        return this;\n    }\n    /**\n     * Specify a predicate that will be used to validate the values.\n     * @param {function} predicateFn\n     * @returns {BaseSchema} - The current instance of the BaseSchema.\n     */\n    predicate(predicateFn) {\n        this.pushValidationFn((value, path) => {\n            if (!predicateFn(value)) {\n                return errors_1.createError(errors_1.ERROR_TYPES.PREDICATE, 'Value failed predicate', path);\n            }\n        });\n        return this;\n    }\n    /**\n     * Specify a set of values that are not valid.\n     * @param {Array.<any>} values\n     * @returns {BaseSchema} - The current instance of the BaseSchema.\n     */\n    not(...values) {\n        this.pushValidationFn((value, path) => {\n            const index = values.findIndex(element => this.areEqual(value, element));\n            if (index !== -1) {\n                return errors_1.createError(errors_1.ERROR_TYPES.ARGUMENT, `Expected value to not equal ${values[index]} but it did`, path);\n            }\n        });\n        return this;\n    }\n    /**\n     * Virtual method that is used to compare two values for equality in .not(). Can be overridden in child classes.\n     * @returns {Boolean} - Returns true if the two values are equal, otherwise returns false.\n     */\n    areEqual(firstValue, secondValue) {\n        return firstValue === secondValue;\n    }\n    /**\n     * Synchronously validates whether a value satisfies the validation rules in the schema instance.\n     * @param {any} value - The value to validate.\n     * @param {string} path - The key of the value to validate.\n     * @param {?[]} errors - Optional error array to push possible validation errors to.\n     */\n    validate(value, path = '', currentErrors) {\n        if (!this.validateType(value)) {\n            if (this._required) {\n                return {\n                    errorsCount: 1,\n                    errors: [errors_1.createError(errors_1.ERROR_TYPES.TYPE, `Expected type ${this.type} but got ${typeof value}`, path)]\n                };\n            }\n            return { errorsCount: 0, errors: [] };\n        }\n        return this.validateValueWithCorrectType(value, path);\n    }\n    /**\n     * Virtual method that synchronously validates whether a value,\n     * which is known to be of a type matching the current schema's type,\n     * satisfies the validation rules in the schema. Can be overridden in child classes.\n     * @param {any} value - The value of matching type to validate.\n     * @param {string} path - The key of the value to validate.\n     * @param {?[]} errors - Options error array to push possible validation errors to.\n     */\n    validateValueWithCorrectType(value, path, currentErrors) {\n        const errors = [];\n        for (let i = 0, len = this.validationFunctions.length; i < len; i += 1) {\n            const err = this.validationFunctions[i](value, path);\n            if (err) {\n                errors.push(err);\n            }\n        }\n        return { errors, errorsCount: errors.length };\n    }\n}\nexports.default = BaseSchema;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/schemas/base-schema.ts\n// module id = 0\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ValidationError {\n    constructor(type, message, path) {\n        this.type = type;\n        this.message = message;\n        this.path = path;\n    }\n}\nexports.ValidationError = ValidationError;\nexports.ERROR_TYPES = Object.freeze({\n    'RANGE': 'range',\n    'ARGUMENT': 'argument',\n    'TYPE': 'type',\n    'PREDICATE': 'predicate'\n});\nexports.createError = (type, message, path) => new ValidationError(type, message, path);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/errors.ts\n// module id = 1\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createIs(type) {\n    const typeName = type[0].toUpperCase() + type.substr(1);\n    return (value) => Object.prototype.toString.call(value) === `[object ${typeName}]`;\n}\nexports.Obj = createIs('object');\nexports.String = createIs('string');\nexports.Number = createIs('number');\nexports.Bool = createIs('boolean');\nexports.Null = createIs('number');\nexports.Undefined = createIs('undefined');\nexports.RegExp = createIs('regExp');\nexports.Date = createIs('date');\nexports.Array = createIs('array');\nexports.Function = createIs('function');\nexports.NullOrUndefined = (value) => exports.Null(value) || exports.Undefined(value);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/is.ts\n// module id = 2\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst errors_1 = require(\"../errors\");\nconst base_schema_1 = require(\"./base-schema\");\nconst is = require(\"../is\");\nexports.name = 'array';\nclass ArraySchema extends base_schema_1.default {\n    constructor(subschema) {\n        super();\n        if (!is.NullOrUndefined(subschema)) {\n            this._state = { subschema: subschema.required(), minlength: 0, maxlength: Infinity };\n        }\n        else {\n            this._state = { minlength: 0, maxlength: Infinity };\n        }\n    }\n    get type() {\n        if (!this._state.typestring) {\n            this._state.typestring = this._state.subschema ? `array<${this._state.subschema.type}>` : `array<any>`;\n        }\n        return this._state.typestring;\n    }\n    validateType(value) {\n        return is.Array(value) && (is.NullOrUndefined(this._state.subschema) || value.every((x) => this._state.subschema.validateType(x)));\n    }\n    minlength(length) {\n        if (ArraySchema._isValidArrayLength(length)) {\n            this._state.minlength = length;\n            this._state.hasMinLength = true;\n        }\n        return this;\n    }\n    maxlength(length) {\n        if (ArraySchema._isValidArrayLength(length)) {\n            this._state.maxlength = length;\n            this._state.hasMaxLength = true;\n        }\n        return this;\n    }\n    withLength(length) {\n        return this.minlength(length).maxlength(length);\n    }\n    distinct() {\n        this.pushValidationFn((value, path) => {\n            if (value.length !== new Set(value).size) {\n                return errors_1.createError(errors_1.ERROR_TYPES.ARGUMENT, `Expected values in ${value} to be distinct`, path);\n            }\n        });\n        return this;\n    }\n    validateValueWithCorrectType(value, path) {\n        const { errors } = super.validateValueWithCorrectType(value, path);\n        if (this._state.hasMinLength && (value.length < this._state.minlength)) {\n            const minLengthError = errors_1.createError(errors_1.ERROR_TYPES.RANGE, `Expected an ${this.type} with length at least ${this._state.minlength} but got length ${value.length}`, path);\n            errors.push(minLengthError);\n            return { errors, errorsCount: errors.length };\n        }\n        if (this._state.hasMaxLength && (value.length > this._state.maxlength)) {\n            const maxLengthError = errors_1.createError(errors_1.ERROR_TYPES.RANGE, `Expected an ${this.type} with length at most ${this._state.maxlength} but got length ${value.length}`, path);\n            errors.push(maxLengthError);\n            return { errors, errorsCount: errors.length };\n        }\n        if (!this._state.subschema) {\n            return { errors, errorsCount: errors.length };\n        }\n        for (let i = 0, len = value.length; i < len; i += 1) {\n            const { errors: subErrors, errorsCount } = this._state.subschema.validate(value[i], path + '[' + i + ']', errors);\n            if (errorsCount > 0) {\n                if (Array.isArray(subErrors)) {\n                    errors.push(...subErrors);\n                }\n                else {\n                    errors.push(subErrors);\n                }\n                return { errors, errorsCount: errors.length };\n            }\n        }\n        return { errors, errorsCount: errors.length };\n    }\n    static _isValidArrayLength(value) {\n        return !isNaN(value) && (value >= 0) && isFinite(value);\n    }\n}\nexports.default = ArraySchema;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/schemas/array-schema.ts\n// module id = 3\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_schema_1 = require(\"./base-schema\");\nconst is = require(\"../is\");\nexports.name = 'bool';\nconst typeName = 'bool';\nclass BoolSchema extends base_schema_1.default {\n    get type() {\n        return typeName;\n    }\n    validateType(value) {\n        return is.Bool(value);\n    }\n}\nexports.default = BoolSchema;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/schemas/bool-schema.ts\n// module id = 4\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst errors_1 = require(\"../errors\");\nconst base_schema_1 = require(\"./base-schema\");\nconst is = require(\"../is\");\nconsole.warn('Warning: DateSchema is still experimental! API changes are possible. Use cautiously in production.');\nexports.name = 'date';\nfunction validateRangeBound(bound) {\n    return is.Number(bound) && !Number.isNaN(bound);\n}\nconst typeName = 'date';\nfunction isInRange(start, end, value) {\n    if (start < end) {\n        return (value < start || end < value);\n    }\n    else {\n        return (end < value && value < start);\n    }\n}\n/**\n * This function is here because typescript is stupid and doesn't understand javascript types and has not compile time templating.\n *\n * @param {keyof Date} componentName\n * @param {Date} dateInstance\n * @returns {number}\n */\nfunction getDateComponent(componentName, dateInstance) {\n    switch (componentName) {\n        case 'getSeconds':\n        case 'getMinutes':\n        case 'getHours':\n        case 'getDay':\n        case 'getMonth':\n        case 'getDate':\n        case 'getFullYear':\n            return dateInstance[componentName]();\n        default:\n            throw new Error('Should never happen in production.');\n    }\n}\nfunction betweenValidation(start, end, ranges, componentName) {\n    const name = componentName.replace(/get/, '').toLowerCase();\n    if (!is.Undefined(ranges['_start' + name] && ranges['_end' + name])) {\n        throw new Error(`Cannot set start and end for ${name} twice on a single DateSchema instance`);\n    }\n    if (!validateRangeBound(start) || !validateRangeBound(end)) {\n        throw new RangeError(`Expected sane integer numbers for start and end of ${name}, but got ${start} and ${end}`);\n    }\n    ranges['_start' + name] = start;\n    ranges['_end' + name] = end;\n    return (value, path) => {\n        const rstart = ranges['_start' + name];\n        const rend = ranges['_end' + name];\n        const valueNumber = getDateComponent(componentName, value);\n        console.log(rstart, rend, valueNumber, !isInRange(rstart, rend, valueNumber));\n        if (!isInRange(rstart, rend, valueNumber)) {\n            return errors_1.createError(errors_1.ERROR_TYPES.RANGE, `Expected ${name} to be in range ${start}:${end} but got ${value}`, path);\n        }\n    };\n}\nclass DateSchema extends base_schema_1.default {\n    constructor() {\n        super();\n        this._state = { ranges: {} };\n    }\n    get type() {\n        return typeName;\n    }\n    /**\n     * Validate whether the provided value is a Date object. Only date objects with valid time are considered valid dates.\n     * @param {any} value - The value to be checked for type Date.\n     * @returns {Boolean}\n     */\n    validateType(value) {\n        return is.Date(value) && !Number.isNaN(value.getTime());\n    }\n    /**\n     * Introduce a before validation to the schema instance - every date equal to or after the provided will be considered invalid.\n     * @param {any} dateConstructorArgs - Arguments that you will typically pass to the Date constructor.\n     * @returns {DateSchema} - Returns the current DateSchema instance to enable chaining.\n     */\n    before(...dateConstructorArgs) {\n        if (!is.Undefined(this._state._before)) {\n            throw new Error('Cannot set before date twice for a date schema instance');\n        }\n        const beforeDate = new Date(...dateConstructorArgs);\n        if (!this.validateType(beforeDate)) {\n            throw new TypeError(`The value provided to .before() is not a valid date string or object ${dateConstructorArgs}`);\n        }\n        const { _state } = this;\n        _state._before = beforeDate;\n        this.pushValidationFn((value, path) => {\n            if (!is.NullOrUndefined(_state._before) && value >= _state._before) {\n                return errors_1.createError(errors_1.ERROR_TYPES.RANGE, `Expected date before ${_state._before} but got ${value}`, path);\n            }\n        });\n        return this;\n    }\n    /**\n     * Introduce an after validation to the schema instance - every date equal to or before the provided will be considered invalid.\n     * @param {any} dateConstructorArgs - Arguments that you will typically pass to the Date constructor.\n     * @returns {DateSchema} - Returns the current DateSchema instance to enable chaining.\n     */\n    after(...dateConstructorArgs) {\n        if (!is.Undefined(this._state._after)) {\n            throw new Error('Cannot set after date twice for a date schema instance');\n        }\n        const afterDate = new Date(...dateConstructorArgs);\n        if (!this.validateType(afterDate)) {\n            throw new TypeError(`The value provided to .after() is not a valid date string or object ${dateConstructorArgs}`);\n        }\n        const { _state } = this;\n        _state._after = afterDate;\n        this.pushValidationFn((value, path) => {\n            if (!is.NullOrUndefined(_state._after) && value <= _state._after) {\n                return errors_1.createError(errors_1.ERROR_TYPES.RANGE, `Expected date after ${_state._after} but got ${value}`, path);\n            }\n        });\n        return this;\n    }\n    /**\n     * Set validation for range on date in month.\n     * If start < end, value will be validated against the range [start, end]\n     * If start > end, value will be validated against the ranges [0, start] and [end, 31]\n     */\n    dateBetween(start, end) {\n        this.pushValidationFn(betweenValidation(start, end, this._state.ranges, 'getDate'));\n        return this;\n    }\n    monthBetween(start, end) {\n        this.pushValidationFn(betweenValidation(start, end, this._state.ranges, 'getMonth'));\n        return this;\n    }\n    hourBetween(start, end) {\n        this.pushValidationFn(betweenValidation(start, end, this._state.ranges, 'getHours'));\n        return this;\n    }\n    weekdayBetween(start, end) {\n        this.pushValidationFn(betweenValidation(start, end, this._state.ranges, 'getDay'));\n        return this;\n    }\n    minutesBetween(start, end) {\n        this.pushValidationFn(betweenValidation(start, end, this._state.ranges, 'getMinutes'));\n        return this;\n    }\n    secondsBetween(start, end) {\n        this.pushValidationFn(betweenValidation(start, end, this._state.ranges, 'getSeconds'));\n        return this;\n    }\n}\nexports.default = DateSchema;\n;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/schemas/date-schema.ts\n// module id = 5\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst errors_1 = require(\"../errors\");\nconst base_schema_1 = require(\"./base-schema\");\nexports.name = 'enumeration';\nconst typeName = 'enumeration';\nclass EnumerationSchema extends base_schema_1.default {\n    constructor(...args) {\n        super();\n        const isMapEnum = args.length === 1 && typeof args[0] === 'object';\n        this._state = {\n            allowedValues: isMapEnum ? Object.keys(args[0]).map(key => args[0][key]) : args\n        };\n        this.pushValidationFn((value, path) => {\n            const index = this._state.allowedValues.indexOf(value);\n            if (index === -1) {\n                return errors_1.createError(errors_1.ERROR_TYPES.ARGUMENT, `Expected one of ${this._state.allowedValues} but got ${value}`, path);\n            }\n        });\n    }\n    get type() {\n        return typeName;\n    }\n    validateType() {\n        return true;\n    }\n}\nexports.default = EnumerationSchema;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/schemas/enumeration-schema.ts\n// module id = 6\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst errors_1 = require(\"../errors\");\nconst base_schema_1 = require(\"./base-schema\");\nconst is = require(\"../is\");\nexports.name = 'number';\nconst typeName = 'number';\nclass NumberSchema extends base_schema_1.default {\n    constructor() {\n        super();\n        this._precision = 0;\n    }\n    get type() {\n        return typeName;\n    }\n    validateType(value) {\n        return is.Number(value)\n            && (this._nanAllowed || !isNaN(value))\n            && (this._infinityAllowed || isFinite(value) || isNaN(value));\n    }\n    precision(allowedDiff) {\n        this._precision = allowedDiff;\n        return this;\n    }\n    allowNaN() {\n        this._nanAllowed = true;\n        return this;\n    }\n    allowInfinity() {\n        this._infinityAllowed = true;\n        return this;\n    }\n    safeInteger() {\n        const newMin = Math.max(this._minvalue || -Number.MAX_SAFE_INTEGER, -Number.MAX_SAFE_INTEGER), newMax = Math.min(this._maxvalue || Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n        return this.min(newMin).max(newMax);\n    }\n    min(minvalue) {\n        if (is.Undefined(this._minvalue)) {\n            this.pushValidationFn((value, path) => {\n                if (value < this._minvalue) {\n                    return errors_1.createError(errors_1.ERROR_TYPES.RANGE, `Expected value greater than or equal to ${minvalue} but got ${value}`, path);\n                }\n            });\n        }\n        this._minvalue = minvalue;\n        return this;\n    }\n    max(maxvalue) {\n        if (is.Undefined(this._maxvalue)) {\n            this.pushValidationFn((value, path) => {\n                if (value > maxvalue) {\n                    return errors_1.createError(errors_1.ERROR_TYPES.RANGE, `Expected value less than or equal to ${maxvalue} but got ${value}`, path);\n                }\n            });\n        }\n        this._maxvalue = maxvalue;\n        return this;\n    }\n    integer() {\n        this.pushValidationFn((value, path) => {\n            if (!Number.isInteger(value + 0)) {\n                return errors_1.createError(errors_1.ERROR_TYPES.ARGUMENT, `Expected integer number but got ${value}`, path);\n            }\n        });\n        return this;\n    }\n    areEqual(firstValue, secondValue) {\n        const diff = Math.abs(firstValue - secondValue);\n        return diff <= this._precision;\n    }\n}\nexports.default = NumberSchema;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/schemas/number-schema.ts\n// module id = 7\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_schema_1 = require(\"./base-schema\");\nconst is = require(\"../is\");\nexports.name = 'object';\nconst typeName = 'object';\nclass ObjectSchema extends base_schema_1.default {\n    constructor(subschema) {\n        super();\n        this._state = {\n            subschema: subschema || {},\n            allowFunctions: false,\n            allowArrays: false\n        };\n    }\n    get type() {\n        return typeName;\n    }\n    validateType(value) {\n        const valueIsArray = is.Array(value);\n        const valueIsFunction = is.Function(value);\n        return is.Obj(value)\n            || (this._state.allowArrays && valueIsArray)\n            || (this._state.allowFunctions && valueIsFunction);\n    }\n    allowArrays() {\n        this._state.allowArrays = true;\n        return this;\n    }\n    allowFunctions() {\n        this._state.allowFunctions = true;\n        return this;\n    }\n    validateValueWithCorrectType(value, path) {\n        const errorsMap = Object.create(null);\n        let currentErrorsCount = 0;\n        for (const key in this._state.subschema) {\n            const { errors, errorsCount } = this._state.subschema[key].validate(value[key], path ? path + '.' + key : key);\n            currentErrorsCount += errorsCount;\n            errorsMap[key] = errors;\n        }\n        return { errors: errorsMap, errorsCount: currentErrorsCount };\n    }\n}\nexports.default = ObjectSchema;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/schemas/object-schema.ts\n// module id = 8\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst errors_1 = require(\"../errors\");\nconst base_schema_1 = require(\"./base-schema\");\nconst is = require(\"../is\");\nexports.name = 'string';\nconst typeName = 'string';\nclass StringSchema extends base_schema_1.default {\n    constructor() {\n        super();\n        this._state = {};\n    }\n    get type() {\n        return typeName;\n    }\n    validateType(value) {\n        return is.String(value);\n    }\n    minlength(length) {\n        if (!is.Undefined(this._state.minlength)) {\n            throw new Error('Cannot set minlength twice for a number schema instance');\n        }\n        this._state.minlength = length;\n        this.pushValidationFn((value, path) => {\n            if (!is.Undefined(this._state.minlength) && this._state.minlength > value.length) {\n                return errors_1.createError(errors_1.ERROR_TYPES.RANGE, `Expected string with length at least ${this._state.minlength} but got ${value.length}`, path);\n            }\n        });\n        return this;\n    }\n    maxlength(length) {\n        if (!is.Undefined(this._state.maxlength)) {\n            throw new Error('Cannot set maxlength twice for a number schema instance');\n        }\n        this._state.maxlength = length;\n        this.pushValidationFn((value, path) => {\n            if (!is.Undefined(this._state.maxlength) && this._state.maxlength < value.length) {\n                return errors_1.createError(errors_1.ERROR_TYPES.RANGE, `Expected string with length at most ${this._state.minlength} but got ${value.length}`, path);\n            }\n        });\n        return this;\n    }\n    pattern(regexp) {\n        if (!is.Undefined(this._state.pattern)) {\n            throw new Error('Cannot set maxlength twice for a number schema instance');\n        }\n        this._state.pattern = regexp;\n        this.pushValidationFn((value, path) => {\n            if (!is.Undefined(this._state.pattern) && !this._state.pattern.test(value)) {\n                return errors_1.createError(errors_1.ERROR_TYPES.ARGUMENT, `Expected ${value} to match pattern but it did not`, path);\n            }\n        });\n        return this;\n    }\n}\nexports.default = StringSchema;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/schemas/string-schema.ts\n// module id = 9\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst base_schema_1 = require(\"./base-schema\");\nexports.name = 'union';\nclass UnionSchema extends base_schema_1.default {\n    constructor(...subschemas) {\n        super();\n        this._state = { subschemas: subschemas.map(x => x.required()) };\n    }\n    get type() {\n        return this._state.typestring || (this._state.typestring = this._state.subschemas.map(schema => schema.type).join('|'));\n    }\n    validateType(value) {\n        return this._state.subschemas.findIndex(schema => schema.validateType(value)) !== -1;\n    }\n    // TODO: refactor\n    // TODO: improve performance, currently .validateType() is executed twice\n    validateValueWithCorrectType(value, path) {\n        const errors = [], unionErrors = [];\n        for (const schema of this._state.subschemas) {\n            if (!schema.validateType(value)) {\n                continue;\n            }\n            const { errors: schemaErrors, errorsCount } = schema.validate(value, path);\n            if (!errorsCount) {\n                return { errors: [], errorsCount: 0 };\n            }\n            if (Array.isArray(schemaErrors)) {\n                unionErrors.push(...schemaErrors);\n            }\n            else {\n                unionErrors.push(schemaErrors);\n            }\n        }\n        errors.push(...unionErrors);\n        return { errors, errorsCount: errors.length };\n    }\n}\nexports.default = UnionSchema;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/schemas/union-schema.ts\n// module id = 10\n// module chunks = 0","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bool_schema_1 = require(\"./schemas/bool-schema\");\nconst array_schema_1 = require(\"./schemas/array-schema\");\nconst enumeration_schema_1 = require(\"./schemas/enumeration-schema\");\nconst number_schema_1 = require(\"./schemas/number-schema\");\nconst object_schema_1 = require(\"./schemas/object-schema\");\nconst string_schema_1 = require(\"./schemas/string-schema\");\nconst union_schema_1 = require(\"./schemas/union-schema\");\nconst date_schema_1 = require(\"./schemas/date-schema\");\nexports.string = () => new string_schema_1.default;\nexports.number = () => new number_schema_1.default;\nexports.bool = () => new bool_schema_1.default;\nexports.date = () => new date_schema_1.default;\nexports.array = (subschema) => new array_schema_1.default(subschema);\nexports.enumeration = (...values) => new enumeration_schema_1.default(...values);\nexports.object = (subschema) => new object_schema_1.default(subschema);\nexports.union = (...subschemas) => new union_schema_1.default(...subschemas);\n__export(require(\"./errors\"));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/index.ts\n// module id = 11\n// module chunks = 0"],"sourceRoot":""}